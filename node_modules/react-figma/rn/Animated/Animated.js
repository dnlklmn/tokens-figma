"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var non_secure_1 = require("nanoid/non-secure");
var React = require("react");
var Animated = /** @class */ (function () {
    function Animated() {
    }
    return Animated;
}());
var AnimatedWithChildren = /** @class */ (function (_super) {
    __extends(AnimatedWithChildren, _super);
    function AnimatedWithChildren() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AnimatedWithChildren;
}(Animated));
var AnimatedInterpolation = /** @class */ (function (_super) {
    __extends(AnimatedInterpolation, _super);
    function AnimatedInterpolation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimatedInterpolation.prototype.interpolate = function (config) {
        return new AnimatedInterpolation();
    };
    return AnimatedInterpolation;
}(AnimatedWithChildren));
/**
 * Standard value for driving animations.  One `Animated.Value` can drive
 * multiple properties in a synchronized fashion, but can only be driven by one
 * mechanism at a time.  Using a new mechanism (e.g. starting a new animation,
 * or calling `setValue`) will stop any previous ones.
 */
var Value = /** @class */ (function (_super) {
    __extends(Value, _super);
    function Value(value) {
        var _this = _super.call(this) || this;
        _this.changeListeners = {};
        _this.value = value;
        return _this;
    }
    /**
     * Directly set the value.  This will stop any animations running on the value
     * and update all the bound properties.
     */
    Value.prototype.setValue = function (value) {
        this.value = value;
    };
    /**
     * Sets an offset that is applied on top of whatever value is set, whether via
     * `setValue`, an animation, or `Animated.event`.  Useful for compensating
     * things like the start of a pan gesture.
     */
    Value.prototype.setOffset = function (offset) {
        this.offset = offset;
    };
    /**
     * Merges the offset value into the base value and resets the offset to zero.
     * The final output of the value is unchanged.
     */
    Value.prototype.flattenOffset = function () {
        this.value += this.offset;
        this.offset = 0;
    };
    /**
     * Sets the offset value to the base value, and resets the base value to zero.
     * The final output of the value is unchanged.
     */
    Value.prototype.extractOffset = function () {
        this.offset = this.value;
        this.value = 0;
    };
    /**
     * Adds an asynchronous listener to the value so you can observe updates from
     * animations.  This is useful because there is no way to
     * synchronously read the value because it might be driven natively.
     */
    Value.prototype.addListener = function (callback) {
        var id = non_secure_1.nanoid();
        this.changeListeners[id] = id;
        return id;
    };
    Value.prototype.removeListener = function (id) {
        delete this.changeListeners[id];
    };
    Value.prototype.removeAllListeners = function () {
        Object.keys(this.changeListeners).forEach(this.removeListener);
    };
    /**
     * Stops any running animation or tracking.  `callback` is invoked with the
     * final value after stopping the animation, which is useful for updating
     * state to match the animation position with layout.
     */
    Value.prototype.stopAnimation = function (callback) { };
    /**
     * Interpolates the value before updating the property, e.g. mapping 0-1 to
     * 0-10.
     */
    Value.prototype.interpolate = function (config) {
        return new AnimatedInterpolation();
    };
    return Value;
}(AnimatedWithChildren));
exports.Value = Value;
/**
 * 2D Value for driving 2D animations, such as pan gestures.  Almost identical
 * API to normal `Animated.Value`, but multiplexed.  Contains two regular
 * `Animated.Value`s under the hood.
 */
var ValueXY = /** @class */ (function (_super) {
    __extends(ValueXY, _super);
    function ValueXY(valueIn) {
        var _this = _super.call(this) || this;
        _this.x = typeof valueIn.x === 'number' ? new Value(valueIn.x) : valueIn.x;
        _this.y = typeof valueIn.y === 'number' ? new Value(valueIn.y) : valueIn.y;
        return _this;
    }
    ValueXY.prototype.setValue = function (value) {
        this.x = new Value(value.x);
        this.y = new Value(value.y);
    };
    ValueXY.prototype.setOffset = function (offset) {
        this.offsetX = offset.x;
        this.offsetY = offset.y;
    };
    ValueXY.prototype.flattenOffset = function () {
        this.x.setValue(this.x.value + this.offsetX);
        this.y.setValue(this.y.value + this.offsetY);
        this.offsetX = 0;
        this.offsetY = 0;
    };
    ValueXY.prototype.extractOffset = function () {
        this.offsetX = this.x.value;
        this.offsetY = this.y.value;
        this.x.setValue(0);
        this.y.setValue(0);
    };
    ValueXY.prototype.stopAnimation = function (callback) { };
    ValueXY.prototype.addListener = function (callback) {
        var id = non_secure_1.nanoid();
        this.changeListeners[id] = id;
        return id;
    };
    ValueXY.prototype.removeListener = function (id) {
        delete this.changeListeners[id];
    };
    /**
     * Converts `{x, y}` into `{left, top}` for use in style, e.g.
     *
     *```javascript
     *  style={this.state.anim.getLayout()}
     *```
     */
    ValueXY.prototype.getLayout = function () {
        return {
            left: this.x,
            top: this.y
        };
    };
    /**
     * Converts `{x, y}` into a useable translation transform, e.g.
     *
     *```javascript
     *  style={{
     *    transform: this.state.anim.getTranslateTransform()
     *  }}
     *```
     */
    ValueXY.prototype.getTranslateTransform = function () {
        return [
            {
                translateX: this.x
            },
            {
                translateY: this.y
            }
        ];
    };
    return ValueXY;
}(AnimatedWithChildren));
exports.ValueXY = ValueXY;
var EmptyCompositeAnimation = /** @class */ (function () {
    function EmptyCompositeAnimation() {
    }
    EmptyCompositeAnimation.prototype.reset = function () { };
    EmptyCompositeAnimation.prototype.start = function (callback) { };
    EmptyCompositeAnimation.prototype.stop = function () { };
    return EmptyCompositeAnimation;
}());
/**
 * Animates a value from an initial velocity to zero based on a decay
 * coefficient.
 */
function decay(value, config) {
    return new EmptyCompositeAnimation();
}
exports.decay = decay;
/**
 * Animates a value along a timed easing curve.  The `Easing` module has tons
 * of pre-defined curves, or you can use your own function.
 */
exports.timing = function () {
    return new EmptyCompositeAnimation();
};
/**
 * Creates a new Animated value composed from two Animated values added
 * together.
 */
function add(a, b) {
    return new AnimatedAddition();
}
exports.add = add;
var AnimatedAddition = /** @class */ (function (_super) {
    __extends(AnimatedAddition, _super);
    function AnimatedAddition() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AnimatedAddition;
}(AnimatedInterpolation));
/**
 * Creates a new Animated value composed by subtracting the second Animated
 * value from the first Animated value.
 */
function subtract(a, b) {
    return new AnimatedSubtraction();
}
exports.subtract = subtract;
var AnimatedSubtraction = /** @class */ (function (_super) {
    __extends(AnimatedSubtraction, _super);
    function AnimatedSubtraction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AnimatedSubtraction;
}(AnimatedInterpolation));
/**
 * Creates a new Animated value composed by dividing the first Animated
 * value by the second Animated value.
 */
function divide(a, b) {
    return new AnimatedDivision();
}
exports.divide = divide;
var AnimatedDivision = /** @class */ (function (_super) {
    __extends(AnimatedDivision, _super);
    function AnimatedDivision() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AnimatedDivision;
}(AnimatedInterpolation));
/**
 * Creates a new Animated value composed from two Animated values multiplied
 * together.
 */
function multiply(a, b) {
    return new AnimatedMultiplication();
}
exports.multiply = multiply;
var AnimatedMultiplication = /** @class */ (function (_super) {
    __extends(AnimatedMultiplication, _super);
    function AnimatedMultiplication() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AnimatedMultiplication;
}(AnimatedInterpolation));
/**
 * Creates a new Animated value that is the (non-negative) modulo of the
 * provided Animated value
 */
function modulo(a, modulus) {
    return new AnimatedModulo();
}
exports.modulo = modulo;
var AnimatedModulo = /** @class */ (function (_super) {
    __extends(AnimatedModulo, _super);
    function AnimatedModulo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AnimatedModulo;
}(AnimatedInterpolation));
/**
 * Create a new Animated value that is limited between 2 values. It uses the
 * difference between the last value so even if the value is far from the bounds
 * it will start changing when the value starts getting closer again.
 * (`value = clamp(value + diff, min, max)`).
 *
 * This is useful with scroll events, for example, to show the navbar when
 * scrolling up and to hide it when scrolling down.
 */
function diffClamp(a, min, max) {
    return new AnimatedDiffClamp();
}
exports.diffClamp = diffClamp;
var AnimatedDiffClamp = /** @class */ (function (_super) {
    __extends(AnimatedDiffClamp, _super);
    function AnimatedDiffClamp() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AnimatedDiffClamp;
}(AnimatedInterpolation));
/**
 * Starts an animation after the given delay.
 */
function delay(time) {
    return new EmptyCompositeAnimation();
}
exports.delay = delay;
/**
 * Starts an array of animations in order, waiting for each to complete
 * before starting the next.  If the current running animation is stopped, no
 * following animations will be started.
 */
function sequence(animations) {
    return new EmptyCompositeAnimation();
}
exports.sequence = sequence;
/**
 * Array of animations may run in parallel (overlap), but are started in
 * sequence with successive delays.  Nice for doing trailing effects.
 */
function stagger(time, animations) {
    return new EmptyCompositeAnimation();
}
exports.stagger = stagger;
/**
 * Loops a given animation continuously, so that each time it reaches the end,
 * it resets and begins again from the start. Can specify number of times to
 * loop using the key 'iterations' in the config. Will loop without blocking
 * the UI thread if the child animation is set to 'useNativeDriver'.
 */
function loop(animation, config) {
    return new EmptyCompositeAnimation();
}
exports.loop = loop;
/**
 * Spring animation based on Rebound and Origami.  Tracks velocity state to
 * create fluid motions as the `toValue` updates, and can be chained together.
 */
function spring(value, config) {
    return new EmptyCompositeAnimation();
}
exports.spring = spring;
/**
 * Starts an array of animations all at the same time.  By default, if one
 * of the animations is stopped, they will all be stopped.  You can override
 * this with the `stopTogether` flag.
 */
function parallel(animations, config) {
    return new EmptyCompositeAnimation();
}
exports.parallel = parallel;
/**
 *  Takes an array of mappings and extracts values from each arg accordingly,
 *  then calls `setValue` on the mapped outputs.  e.g.
 *
 *```javascript
 *  onScroll={Animated.event(
 *    [{nativeEvent: {contentOffset: {x: this._scrollX}}}]
 *    {listener},          // Optional async listener
 *  )
 *  ...
 *  onPanResponderMove: Animated.event([
 *    null,                // raw event arg ignored
 *    {dx: this._panX},    // gestureState arg
 *  ]),
 *```
 */
function event(argMapping, config) {
    return function () { };
}
exports.event = event;
var AnimatedComponentImpl = function () { return null; };
/**
 * Make any React component Animatable.  Used to create `Animated.View`, etc.
 */
function createAnimatedComponent(component) {
    return AnimatedComponentImpl;
}
exports.createAnimatedComponent = createAnimatedComponent;
/**
 * Animated variants of the basic native views. Accepts Animated.Value for
 * props and style.
 */
exports.View = AnimatedComponentImpl;
exports.Image = AnimatedComponentImpl;
exports.Text = AnimatedComponentImpl;
exports.ScrollView = AnimatedComponentImpl;
/**
 * FlatList and SectionList infer generic Type defined under their `data` and `section` props.
 */
var FlatList = /** @class */ (function (_super) {
    __extends(FlatList, _super);
    function FlatList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return FlatList;
}(React.Component));
exports.FlatList = FlatList;
var SectionList = /** @class */ (function (_super) {
    __extends(SectionList, _super);
    function SectionList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SectionList;
}(React.Component));
exports.SectionList = SectionList;
//# sourceMappingURL=Animated.js.map