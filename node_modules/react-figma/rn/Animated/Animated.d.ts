import { _Image, _ScrollView, _Text, _View, DefaultSectionT, FlatListProps, NativeSyntheticEvent, SectionListProps } from 'react-native';
import * as React from 'react';
declare type AnimatedValue = Value;
declare type AnimatedValueXY = ValueXY;
declare class Animated {
}
declare class AnimatedWithChildren extends Animated {
}
declare class AnimatedInterpolation extends AnimatedWithChildren {
    interpolate(config: InterpolationConfigType): AnimatedInterpolation;
}
declare type ExtrapolateType = 'extend' | 'identity' | 'clamp';
declare type InterpolationConfigType = {
    inputRange: number[];
    outputRange: number[] | string[];
    easing?: (input: number) => number;
    extrapolate?: ExtrapolateType;
    extrapolateLeft?: ExtrapolateType;
    extrapolateRight?: ExtrapolateType;
};
declare type ValueListenerCallback = (state: {
    value: number;
}) => void;
/**
 * Standard value for driving animations.  One `Animated.Value` can drive
 * multiple properties in a synchronized fashion, but can only be driven by one
 * mechanism at a time.  Using a new mechanism (e.g. starting a new animation,
 * or calling `setValue`) will stop any previous ones.
 */
export declare class Value extends AnimatedWithChildren {
    value: number;
    offset: number;
    private changeListeners;
    constructor(value: number);
    /**
     * Directly set the value.  This will stop any animations running on the value
     * and update all the bound properties.
     */
    setValue(value: number): void;
    /**
     * Sets an offset that is applied on top of whatever value is set, whether via
     * `setValue`, an animation, or `Animated.event`.  Useful for compensating
     * things like the start of a pan gesture.
     */
    setOffset(offset: number): void;
    /**
     * Merges the offset value into the base value and resets the offset to zero.
     * The final output of the value is unchanged.
     */
    flattenOffset(): void;
    /**
     * Sets the offset value to the base value, and resets the base value to zero.
     * The final output of the value is unchanged.
     */
    extractOffset(): void;
    /**
     * Adds an asynchronous listener to the value so you can observe updates from
     * animations.  This is useful because there is no way to
     * synchronously read the value because it might be driven natively.
     */
    addListener(callback: ValueListenerCallback): string;
    removeListener(id: string): void;
    removeAllListeners(): void;
    /**
     * Stops any running animation or tracking.  `callback` is invoked with the
     * final value after stopping the animation, which is useful for updating
     * state to match the animation position with layout.
     */
    stopAnimation(callback?: (value: number) => void): void;
    /**
     * Interpolates the value before updating the property, e.g. mapping 0-1 to
     * 0-10.
     */
    interpolate(config: InterpolationConfigType): AnimatedInterpolation;
}
declare type ValueXYListenerCallback = (value: {
    x: number;
    y: number;
}) => void;
/**
 * 2D Value for driving 2D animations, such as pan gestures.  Almost identical
 * API to normal `Animated.Value`, but multiplexed.  Contains two regular
 * `Animated.Value`s under the hood.
 */
export declare class ValueXY extends AnimatedWithChildren {
    x: AnimatedValue;
    y: AnimatedValue;
    private offsetX;
    private offsetY;
    private changeListeners;
    constructor(valueIn?: {
        x: number | AnimatedValue;
        y: number | AnimatedValue;
    });
    setValue(value: {
        x: number;
        y: number;
    }): void;
    setOffset(offset: {
        x: number;
        y: number;
    }): void;
    flattenOffset(): void;
    extractOffset(): void;
    stopAnimation(callback?: (value: {
        x: number;
        y: number;
    }) => void): void;
    addListener(callback: ValueXYListenerCallback): string;
    removeListener(id: string): void;
    /**
     * Converts `{x, y}` into `{left, top}` for use in style, e.g.
     *
     *```javascript
     *  style={this.state.anim.getLayout()}
     *```
     */
    getLayout(): {
        [key: string]: AnimatedValue;
    };
    /**
     * Converts `{x, y}` into a useable translation transform, e.g.
     *
     *```javascript
     *  style={{
     *    transform: this.state.anim.getTranslateTransform()
     *  }}
     *```
     */
    getTranslateTransform(): [{
        translateX: AnimatedValue;
    }, {
        translateY: AnimatedValue;
    }];
}
declare type EndResult = {
    finished: boolean;
};
declare type EndCallback = (result: EndResult) => void;
export interface CompositeAnimation {
    /**
     * Animations are started by calling start() on your animation.
     * start() takes a completion callback that will be called when the
     * animation is done or when the animation is done because stop() was
     * called on it before it could finish.
     *
     * @param callback - Optional function that will be called
     *      after the animation finished running normally or when the animation
     *      is done because stop() was called on it before it could finish
     *
     * @example
     *   Animated.timing({}).start(({ finished }) => {
     *    // completion callback
     *   });
     */
    start: (callback?: EndCallback) => void;
    /**
     * Stops any running animation.
     */
    stop: () => void;
    /**
     * Stops any running animation and resets the value to its original.
     */
    reset: () => void;
}
interface AnimationConfig {
    isInteraction?: boolean;
    useNativeDriver: boolean;
}
/**
 * Animates a value from an initial velocity to zero based on a decay
 * coefficient.
 */
export declare function decay(value: AnimatedValue | AnimatedValueXY, config: DecayAnimationConfig): CompositeAnimation;
interface DecayAnimationConfig extends AnimationConfig {
    velocity: number | {
        x: number;
        y: number;
    };
    deceleration?: number;
}
/**
 * Animates a value along a timed easing curve.  The `Easing` module has tons
 * of pre-defined curves, or you can use your own function.
 */
export declare const timing: (value: AnimatedValue | AnimatedValueXY, config: TimingAnimationConfig) => CompositeAnimation;
interface TimingAnimationConfig extends AnimationConfig {
    toValue: number | AnimatedValue | {
        x: number;
        y: number;
    } | AnimatedValueXY | AnimatedInterpolation;
    easing?: (value: number) => number;
    duration?: number;
    delay?: number;
}
interface SpringAnimationConfig extends AnimationConfig {
    toValue: number | AnimatedValue | {
        x: number;
        y: number;
    } | AnimatedValueXY;
    overshootClamping?: boolean;
    restDisplacementThreshold?: number;
    restSpeedThreshold?: number;
    velocity?: number | {
        x: number;
        y: number;
    };
    bounciness?: number;
    speed?: number;
    tension?: number;
    friction?: number;
    stiffness?: number;
    mass?: number;
    damping?: number;
    delay?: number;
}
interface LoopAnimationConfig {
    iterations?: number;
    /**
     * Defaults to `true`
     */
    resetBeforeIteration?: boolean;
}
/**
 * Creates a new Animated value composed from two Animated values added
 * together.
 */
export declare function add(a: Animated, b: Animated): AnimatedAddition;
declare class AnimatedAddition extends AnimatedInterpolation {
}
/**
 * Creates a new Animated value composed by subtracting the second Animated
 * value from the first Animated value.
 */
export declare function subtract(a: Animated, b: Animated): AnimatedSubtraction;
declare class AnimatedSubtraction extends AnimatedInterpolation {
}
/**
 * Creates a new Animated value composed by dividing the first Animated
 * value by the second Animated value.
 */
export declare function divide(a: Animated, b: Animated): AnimatedDivision;
declare class AnimatedDivision extends AnimatedInterpolation {
}
/**
 * Creates a new Animated value composed from two Animated values multiplied
 * together.
 */
export declare function multiply(a: Animated, b: Animated): AnimatedMultiplication;
declare class AnimatedMultiplication extends AnimatedInterpolation {
}
/**
 * Creates a new Animated value that is the (non-negative) modulo of the
 * provided Animated value
 */
export declare function modulo(a: Animated, modulus: number): AnimatedModulo;
declare class AnimatedModulo extends AnimatedInterpolation {
}
/**
 * Create a new Animated value that is limited between 2 values. It uses the
 * difference between the last value so even if the value is far from the bounds
 * it will start changing when the value starts getting closer again.
 * (`value = clamp(value + diff, min, max)`).
 *
 * This is useful with scroll events, for example, to show the navbar when
 * scrolling up and to hide it when scrolling down.
 */
export declare function diffClamp(a: Animated, min: number, max: number): AnimatedDiffClamp;
declare class AnimatedDiffClamp extends AnimatedInterpolation {
}
/**
 * Starts an animation after the given delay.
 */
export declare function delay(time: number): CompositeAnimation;
/**
 * Starts an array of animations in order, waiting for each to complete
 * before starting the next.  If the current running animation is stopped, no
 * following animations will be started.
 */
export declare function sequence(animations: Array<CompositeAnimation>): CompositeAnimation;
/**
 * Array of animations may run in parallel (overlap), but are started in
 * sequence with successive delays.  Nice for doing trailing effects.
 */
export declare function stagger(time: number, animations: Array<CompositeAnimation>): CompositeAnimation;
/**
 * Loops a given animation continuously, so that each time it reaches the end,
 * it resets and begins again from the start. Can specify number of times to
 * loop using the key 'iterations' in the config. Will loop without blocking
 * the UI thread if the child animation is set to 'useNativeDriver'.
 */
export declare function loop(animation: CompositeAnimation, config?: LoopAnimationConfig): CompositeAnimation;
/**
 * Spring animation based on Rebound and Origami.  Tracks velocity state to
 * create fluid motions as the `toValue` updates, and can be chained together.
 */
export declare function spring(value: AnimatedValue | AnimatedValueXY, config: SpringAnimationConfig): CompositeAnimation;
declare type ParallelConfig = {
    stopTogether?: boolean;
};
/**
 * Starts an array of animations all at the same time.  By default, if one
 * of the animations is stopped, they will all be stopped.  You can override
 * this with the `stopTogether` flag.
 */
export declare function parallel(animations: Array<CompositeAnimation>, config?: ParallelConfig): CompositeAnimation;
declare type Mapping = {
    [key: string]: Mapping;
} | AnimatedValue;
interface EventConfig<T> {
    listener?: (event: NativeSyntheticEvent<T>) => void;
    useNativeDriver: boolean;
}
/**
 *  Takes an array of mappings and extracts values from each arg accordingly,
 *  then calls `setValue` on the mapped outputs.  e.g.
 *
 *```javascript
 *  onScroll={Animated.event(
 *    [{nativeEvent: {contentOffset: {x: this._scrollX}}}]
 *    {listener},          // Optional async listener
 *  )
 *  ...
 *  onPanResponderMove: Animated.event([
 *    null,                // raw event arg ignored
 *    {dx: this._panX},    // gestureState arg
 *  ]),
 *```
 */
export declare function event<T>(argMapping: Array<Mapping | null>, config?: EventConfig<T>): (...args: any[]) => void;
export declare type ComponentProps<T> = T extends React.ComponentType<infer P> | React.Component<infer P> ? P : never;
export declare type LegacyRef<C> = {
    getNode(): C;
};
declare type Nullable = undefined | null;
declare type Primitive = string | number | boolean | symbol;
declare type Builtin = Function | Date | Error | RegExp;
interface WithAnimatedArray<P> extends Array<WithAnimatedValue<P>> {
}
declare type WithAnimatedObject<T> = {
    [K in keyof T]: WithAnimatedValue<T[K]>;
};
export declare type WithAnimatedValue<T> = T extends Builtin | Nullable ? T : T extends Primitive ? T | Value | AnimatedInterpolation : T extends Array<infer P> ? WithAnimatedArray<P> : T extends {} ? WithAnimatedObject<T> : T;
declare type NonAnimatedProps = 'key' | 'ref';
declare type TAugmentRef<T> = T extends React.Ref<infer R> ? React.Ref<R | LegacyRef<R>> : never;
export declare type AnimatedProps<T> = {
    [key in keyof T]: key extends NonAnimatedProps ? key extends 'ref' ? TAugmentRef<T[key]> : T[key] : WithAnimatedValue<T[key]>;
};
export interface AnimatedComponent<T extends React.ComponentType<any>> extends React.FC<AnimatedProps<React.ComponentPropsWithRef<T>>> {
}
/**
 * Make any React component Animatable.  Used to create `Animated.View`, etc.
 */
export declare function createAnimatedComponent<T extends React.ComponentType<any>>(component: T): AnimatedComponent<T>;
/**
 * Animated variants of the basic native views. Accepts Animated.Value for
 * props and style.
 */
export declare const View: AnimatedComponent<typeof _View>;
export declare const Image: AnimatedComponent<typeof _Image>;
export declare const Text: AnimatedComponent<typeof _Text>;
export declare const ScrollView: AnimatedComponent<typeof _ScrollView>;
/**
 * FlatList and SectionList infer generic Type defined under their `data` and `section` props.
 */
export declare class FlatList<ItemT = any> extends React.Component<AnimatedProps<FlatListProps<ItemT>>> {
}
export declare class SectionList<ItemT = any, SectionT = DefaultSectionT> extends React.Component<AnimatedProps<SectionListProps<ItemT, SectionT>>> {
}
export {};
