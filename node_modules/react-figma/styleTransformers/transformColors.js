"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _parse = require("color-parse");
var gradientParser_1 = require("../helpers/gradientParser");
var parse = typeof _parse === 'function' ? _parse : _parse.default;
exports.colorToRGB = function (color) {
    var parsed = parse(color);
    if (parsed && parsed.space === 'rgb') {
        return {
            r: parsed.values[0] / 255.0,
            g: parsed.values[1] / 255.0,
            b: parsed.values[2] / 255.0
        };
    }
};
exports.colorToRGBA = function (color, opacity) {
    var parsed = parse(color);
    if (parsed && parsed.space === 'rgb') {
        return {
            r: parsed.values[0] / 255.0,
            g: parsed.values[1] / 255.0,
            b: parsed.values[2] / 255.0,
            a: typeof opacity === 'number' ? opacity : parsed.alpha
        };
    }
};
var transformAngleToFigmaTransformation = function (value) {
    var angle = value - Math.PI / 2;
    // **
    // There is rotation relative to center through affine transformation
    // (xc, yc) is a center of the imaginary 1x1 quad
    // (dxc, dyc) is a delta between the old center and the new center (after transformation)
    // Transformation matrix has transform to the delta value, because center position should not change.
    // **
    var xc = 0.5;
    var yc = 0.5;
    var dxc = xc - (Math.cos(angle) * xc + Math.sin(angle) * yc);
    var dyc = yc - (-Math.sin(angle) * xc + Math.cos(angle) * yc);
    return [[Math.cos(angle), Math.sin(angle), dxc], [-Math.sin(angle), Math.cos(angle), dyc]];
};
exports.colorToPaint = function (color) {
    var parsedGradients;
    try {
        parsedGradients = gradientParser_1.default.parse(color);
    }
    catch (e) { }
    var parsedGradient = parsedGradients && parsedGradients[0];
    if (parsedGradient && parsedGradient.type === 'linear-gradient') {
        var gradientTransform = transformAngleToFigmaTransformation(Math.PI);
        if (parsedGradient.orientation) {
            var orientation_1 = parsedGradient.orientation;
            if (orientation_1.type === 'directional') {
                if (orientation_1.value === 'right') {
                    gradientTransform = transformAngleToFigmaTransformation(Math.PI / 2);
                }
                else if (orientation_1.value === 'left') {
                    gradientTransform = transformAngleToFigmaTransformation(-Math.PI / 2);
                }
                else if (orientation_1.value === 'top') {
                    gradientTransform = transformAngleToFigmaTransformation(0);
                }
            }
            else if (orientation_1.type == 'angular') {
                var angle = (parseFloat(orientation_1.value) / 180) * Math.PI;
                gradientTransform = transformAngleToFigmaTransformation(angle);
            }
        }
        return {
            type: 'GRADIENT_LINEAR',
            gradientTransform: gradientTransform,
            gradientStops: parsedGradient.colorStops.map(function (_a, index) {
                var type = _a.type, value = _a.value, length = _a.length;
                return ({
                    position: length && length.type === '%' ? parseFloat(length.value) / 100 : index === 0 ? 0 : 1,
                    color: exports.colorToRGBA(type === 'hex' ? "#" + value : value)
                });
            })
        };
    }
    var _a = exports.colorToRGBA(color), alpha = _a.a, rbg = __rest(_a, ["a"]);
    return { type: 'SOLID', color: rbg, opacity: alpha };
};
//# sourceMappingURL=transformColors.js.map