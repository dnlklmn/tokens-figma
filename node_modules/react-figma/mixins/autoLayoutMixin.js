"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var propsAssign_1 = require("../helpers/propsAssign");
exports.autoLayoutAssign = propsAssign_1.propsAssign([
    'layoutMode',
    'primaryAxisSizingMode',
    'counterAxisSizingMode',
    'primaryAxisAlignItems',
    'counterAxisAlignItems',
    'paddingLeft',
    'paddingRight',
    'paddingTop',
    'paddingBottom',
    'itemSpacing'
], {
    layoutMode: 'NONE',
    primaryAxisAlignItems: 'MIN',
    primaryAxisSizingMode: 'AUTO',
    counterAxisAlignItems: 'MIN',
    counterAxisSizingMode: 'AUTO',
    itemSpacing: 0,
    paddingLeft: 0,
    paddingRight: 0,
    paddingTop: 0,
    paddingBottom: 0
});
var transformPaddings = function (props) {
    return __assign({}, (props.horizontalPadding
        ? { paddingLeft: props.horizontalPadding, paddingRight: props.horizontalPadding }
        : {}), (props.verticalPadding ? { paddingTop: props.verticalPadding, paddingBottom: props.verticalPadding } : {}), props);
};
exports.autoLayoutMixin = function (node) { return function (props) {
    return exports.autoLayoutAssign(node)(transformPaddings(props));
}; };
//# sourceMappingURL=autoLayoutMixin.js.map