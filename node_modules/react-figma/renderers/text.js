"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var baseNodeMixin_1 = require("../mixins/baseNodeMixin");
var geometryMixin_1 = require("../mixins/geometryMixin");
var layoutMixin_1 = require("../mixins/layoutMixin");
var saveStyleMixin_1 = require("../mixins/saveStyleMixin");
var propsAssign_1 = require("../helpers/propsAssign");
var exportMixin_1 = require("../mixins/exportMixin");
var blendMixin_1 = require("../mixins/blendMixin");
var isValidSize_1 = require("../helpers/isValidSize");
var isEqualFontStyle_1 = require("../helpers/isEqualFontStyle");
var sceneNodeMixin_1 = require("../mixins/sceneNodeMixin");
var rpc_1 = require("../rpc");
var safeGetPluginData_1 = require("../helpers/safeGetPluginData");
var constraintsMixin_1 = require("../mixins/constraintsMixin");
var textNodePropsAssign = propsAssign_1.propsAssign([
    'characters',
    'textAlignHorizontal',
    'textAlignVertical',
    'paragraphIndent',
    'paragraphSpacing',
    'autoRename',
    'fontSize',
    'textCase',
    'textDecoration',
    'letterSpacing',
    'lineHeight',
    'textStyleId',
    'hyperlink'
], {
    characters: '',
    textAlignHorizontal: 'LEFT',
    textAlignVertical: 'TOP',
    paragraphIndent: 0,
    paragraphSpacing: 0,
    autoRename: false,
    fontSize: 12,
    textCase: 'ORIGINAL',
    textDecoration: 'NONE',
    letterSpacing: { value: 0, unit: 'PIXELS' },
    lineHeight: { unit: 'AUTO' },
    hyperlink: null
});
var defaultFont = { family: 'Roboto', style: 'Regular' };
exports.text = function (node) { return function (props) {
    var textNode = node || props.node || figma.createText();
    baseNodeMixin_1.baseNodeMixin(textNode)(props);
    saveStyleMixin_1.saveStyleMixin(textNode)(props);
    layoutMixin_1.layoutMixin(textNode)(props);
    geometryMixin_1.geometryMixin(textNode)(props);
    exportMixin_1.exportMixin(textNode)(props);
    blendMixin_1.blendMixin(textNode)(props);
    sceneNodeMixin_1.sceneNodeMixin(textNode)(props);
    constraintsMixin_1.constraintsMixin(textNode)(props);
    var loadedFont = props.loadedFont, _a = props.fontName, fontName = _a === void 0 ? defaultFont : _a;
    if (loadedFont &&
        fontName &&
        loadedFont.family === fontName.family &&
        isEqualFontStyle_1.isEqualFontStyle(loadedFont.style, fontName.style)) {
        if (props.fontName) {
            textNode.fontName = loadedFont;
        }
        if (props.hasDefinedWidth &&
            isValidSize_1.isValidSize(props.width) &&
            isValidSize_1.isValidSize(textNode.height) &&
            !props.textAutoResize) {
            textNode.resize(props.width, textNode.height);
            textNode.textAutoResize = 'HEIGHT';
        }
        else {
            textNode.textAutoResize = props.textAutoResize || 'WIDTH_AND_HEIGHT';
        }
        var oldCharacters = textNode.characters;
        var oldFontSize = textNode.fontSize;
        textNodePropsAssign(textNode)(props);
        if (oldCharacters !== textNode.characters || oldFontSize !== textNode.fontSize) {
            var reactId = safeGetPluginData_1.safeGetPluginData('reactId')(textNode);
            if (reactId) {
                rpc_1.uiApi.updateYogaNode(reactId);
            }
        }
    }
    return textNode;
}; };
//# sourceMappingURL=text.js.map