"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var figma_jsonrpc_1 = require("figma-jsonrpc");
var isReactFigmaNode_1 = require("./helpers/isReactFigmaNode");
var renderers = require("./renderers");
var non_secure_1 = require("nanoid/non-secure");
var rxjs_1 = require("rxjs");
var safeGetPluginData_1 = require("./helpers/safeGetPluginData");
var isEqualFontStyle_1 = require("./helpers/isEqualFontStyle");
var getInitialTree = function (node) {
    return {
        id: node.id,
        type: node.type,
        reactId: safeGetPluginData_1.safeGetPluginData('reactId')(node),
        children: node.children && node.children.filter(function (item) { return isReactFigmaNode_1.isReactFigmaNode(item); }).map(function (item) { return getInitialTree(item); })
    };
};
var findRoot = function (node) {
    if (!node) {
        return;
    }
    var parent = node.parent;
    if (!parent || !isReactFigmaNode_1.isReactFigmaNode(parent)) {
        return node;
    }
    else {
        return findRoot(parent);
    }
};
var transformNodesToTree = function (node) {
    if (!isReactFigmaNode_1.isReactFigmaNode(node)) {
        return;
    }
    var nodeBatchId = non_secure_1.nanoid();
    node.setPluginData('nodeBatchId', nodeBatchId);
    var children = node.children && node.children.map(transformNodesToTree).filter(function (item) { return !!item; });
    return {
        width: node.width,
        height: node.height,
        style: (safeGetPluginData_1.safeGetPluginData('reactStyle')(node) && JSON.parse(safeGetPluginData_1.safeGetPluginData('reactStyle')(node) || '')) ||
            undefined,
        children: children && children.length > 0 ? children : undefined,
        reactId: safeGetPluginData_1.safeGetPluginData('reactId')(node),
        nodeBatchId: nodeBatchId
    };
};
var renderInstance = function (type, node, props, reactId) {
    var instance = renderers[type](node)(props);
    if (!node) {
        instance.setPluginData('isReactFigmaNode', 'true');
        instance.setPluginData('reactId', reactId);
    }
    return instance;
};
var cleanStubElements = function (parentNode) {
    if (parentNode.type === 'GROUP') {
        parentNode.children.forEach(function (child) {
            if (safeGetPluginData_1.safeGetPluginData('isGroupStubElement')(child)) {
                child.remove();
            }
        });
    }
    if (parentNode.type === 'COMPONENT_SET') {
        parentNode.children.forEach(function (child) {
            if (safeGetPluginData_1.safeGetPluginData('isComponentStubElement')(child)) {
                child.remove();
            }
        });
    }
};
var appendToContainer = function (parentNode, childNode) {
    if (!childNode || !parentNode || parentNode.type === 'INSTANCE') {
        return;
    }
    parentNode.appendChild(childNode);
    cleanStubElements(parentNode);
};
var insertToContainer = function (parentNode, newChildNode, beforeChildNode) {
    if (!parentNode || !newChildNode || !beforeChildNode || parentNode.type === 'INSTANCE') {
        return;
    }
    var beforeChildIndex = parentNode.children.indexOf(beforeChildNode);
    parentNode.insertChild(beforeChildIndex, newChildNode);
    cleanStubElements(parentNode);
};
var cache = {};
var transformToNode = function (smth) {
    if (!smth) {
        return;
    }
    if (smth.id) {
        return figma.getNodeById(smth.id);
    }
    else if (smth.reactId) {
        return cache[smth.reactId];
    }
    else {
        return smth;
    }
};
var findNodeByName = function (children, name) {
    return children && children.find(function (child) { return child.name === name || findNodeByName(child.children, name); });
};
exports.api = figma_jsonrpc_1.createPluginAPI({
    getInitialTree: function () {
        return getInitialTree(figma.root);
    },
    renderInstance: function (type, _node, props, tempNode) {
        var node = transformToNode(_node);
        var instance = renderInstance(type, node, props && __assign({}, props, (type === 'instance' && props.component ? { component: transformToNode(props.component) } : {}), (props.node ? { node: transformToNode(props.node) } : {})), tempNode.reactId);
        cache[tempNode.reactId] = instance;
        exports.uiApi.bindReactIdWithNode(tempNode.reactId, instance.id);
    },
    appendToContainer: function (_parentNode, _childNode) {
        var parentNode = transformToNode(_parentNode);
        var childNode = transformToNode(_childNode);
        appendToContainer(parentNode, childNode);
    },
    insertToContainer: function (_parentNode, _newChildNode, _beforeChildNode) {
        var parentNode = transformToNode(_parentNode);
        var newChildNode = transformToNode(_newChildNode);
        var beforeChildNode = transformToNode(_beforeChildNode);
        insertToContainer(parentNode, newChildNode, beforeChildNode);
    },
    listAvailableFontsAsync: function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, figma.listAvailableFontsAsync()];
            });
        });
    },
    loadFontAsync: function (fontName) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, figma.loadFontAsync(fontName)];
            });
        });
    },
    remove: function (_childNode) {
        var childNode = transformToNode(_childNode);
        if (!childNode || childNode.removed) {
            return;
        }
        childNode.remove();
    },
    getTreeForYoga: function (_instance) {
        var node = transformToNode(_instance);
        var root = findRoot(node);
        return transformNodesToTree(root);
    },
    findNodeByName: function (_node, name) {
        var node = transformToNode(_node);
        var instanceItemNode = findNodeByName(node.children, name);
        return instanceItemNode && getInitialTree(instanceItemNode);
    },
    createImage: function (data) {
        var image = figma.createImage(data);
        return image.hash;
    },
    setCurrentPage: function (_node) {
        var node = transformToNode(_node);
        figma.currentPage = node;
    },
    highlightNativeElement: function (_node) {
        var node = transformToNode(_node);
        if (!node || node.type === 'DOCUMENT') {
            return;
        }
        if (figma.currentPage.selection.includes(node)) {
            return;
        }
        var nodePage = findRoot(node);
        if (figma.currentPage !== nodePage) {
            figma.currentPage = nodePage;
        }
        if (node.type !== 'PAGE') {
            figma.viewport.scrollAndZoomIntoView([node]);
            figma.currentPage.selection = [node];
        }
    },
    createOrUpdatePaintStyle: function (properties) {
        var paints = properties.paints, params = properties.params;
        var name = params.name, id = params.id, description = params.description;
        var foundPaintStyle = figma.getLocalPaintStyles().find(function (style) { return style.name === name || style.id === id; });
        var paintStyle = foundPaintStyle || figma.createPaintStyle();
        if (name) {
            paintStyle.name = name;
        }
        if (description) {
            paintStyle.description = description;
        }
        if (paints) {
            paintStyle.paints = paints;
        }
        return paintStyle.id;
    },
    createOrUpdateTextStyle: function (properties) {
        var _a = properties.textProperties, textProperties = _a === void 0 ? {} : _a, params = properties.params, loadedFont = properties.loadedFont;
        var name = params.name, id = params.id, description = params.description;
        var foundTextStyle = figma.getLocalTextStyles().find(function (style) { return style.name === name || style.id === id; });
        var textStyle = foundTextStyle || figma.createTextStyle();
        if (name) {
            textStyle.name = name;
        }
        if (description) {
            textStyle.description = description;
        }
        var _b = textProperties.fontName, fontName = _b === void 0 ? { family: 'Roboto', style: 'Regular' } : _b;
        if (loadedFont &&
            fontName &&
            loadedFont.family === fontName.family &&
            isEqualFontStyle_1.isEqualFontStyle(loadedFont.style, fontName.style)) {
            Object.keys(textProperties).forEach(function (key) {
                textStyle[key] = textProperties[key];
            });
        }
        return textStyle.id;
    }
}, {
    timeout: 60 * 1000
});
exports.setupMainThread = function () {
    figma.on('currentpagechange', function () {
        var reactId = figma.currentPage.getPluginData('reactId');
        exports.uiApi.currentPageChange(reactId);
    });
    figma.on('selectionchange', function () {
        var reactIds = figma.currentPage.selection.map(safeGetPluginData_1.safeGetPluginData('reactId'));
        exports.uiApi.selectionChange(reactIds);
    });
};
exports.$currentPageTempId = new rxjs_1.Subject();
exports.$selectionReactIds = new rxjs_1.Subject();
exports.$updateYogaReactId = new rxjs_1.Subject();
exports.$bindReactIdWithNodeId = new rxjs_1.Subject();
// those methods will be executed in the Figma UI,
// regardless of where they are called from
exports.uiApi = figma_jsonrpc_1.createUIAPI({
    currentPageChange: function (reactId) {
        exports.$currentPageTempId.next(reactId);
    },
    selectionChange: function (reactIds) {
        exports.$selectionReactIds.next(reactIds);
    },
    updateYogaNode: function (reactId) {
        exports.$updateYogaReactId.next(reactId);
    },
    bindReactIdWithNode: function (reactId, nodeId) {
        exports.$bindReactIdWithNodeId.next([reactId, nodeId]);
    }
}, {
    timeout: 60 * 1000
});
//# sourceMappingURL=rpc.js.map